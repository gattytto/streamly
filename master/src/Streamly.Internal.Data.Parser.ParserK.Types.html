<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-cpp">#include &quot;inline.hs&quot;
</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- Module      : Streamly.Internal.Data.Parser.ParserK.Types</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Copyright   : (c) 2020 Composewell Technologies</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- License     : BSD-3-Clause</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Maintainer  : streamly@composewell.com</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Stability   : experimental</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Portability : GHC</span><span>
</span><span id="line-10"></span><span class="hs-comment">--</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- CPS style implementation of parsers.</span><span>
</span><span id="line-12"></span><span class="hs-comment">--</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- The CPS representation allows linear performance for Applicative, sequenceA,</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- Monad, sequence, and Alternative, choice operations compared to the</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- quadratic complexity of the corresponding direct style operations. However,</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- direct style operations allow fusion with ~10x better performance than CPS.</span><span>
</span><span id="line-17"></span><span class="hs-comment">--</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- The direct style representation does not allow for recursive definitions of</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- &quot;some&quot; and &quot;many&quot; whereas CPS allows that.</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Streamly.Internal.Data.Parser.ParserK.Types</span><span>
</span><span id="line-22"></span><span>    </span><span class="hs-special">(</span><span>
</span><span id="line-23"></span><span>      </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-24"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#yield"><span class="hs-identifier">yield</span></a></span><span>
</span><span id="line-25"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier">die</span></a></span><span>
</span><span id="line-26"></span><span>    </span><span class="hs-special">)</span><span>
</span><span id="line-27"></span><span class="hs-keyword">where</span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadPlus</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ap</span></span><span class="hs-special">)</span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Alternative</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Zipper.html"><span class="hs-identifier">Streamly.Internal.Data.Zipper</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Zipper.html#Zipper"><span class="hs-identifier">Zipper</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Zipper.html"><span class="hs-identifier">Streamly.Internal.Data.Zipper</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Z</span></span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-keyword">newtype</span><span> </span><span id="Parser"><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-var">Parser</span></a></span></span><span> </span><span id="local-6989586621679280155"><span class="annot"><a href="#local-6989586621679280155"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679280154"><span class="annot"><a href="#local-6989586621679280154"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679280153"><span class="annot"><a href="#local-6989586621679280153"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-35"></span><span>    </span><span id="MkParser"><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="runParser"><span class="annot"><span class="annottext">Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679280167"><span class="annot"><a href="#local-6989586621679280167"><span class="hs-identifier hs-type">r</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-36"></span><span>        </span><span class="annot"><a href="Streamly.Internal.Data.Zipper.html#Zipper"><span class="hs-identifier hs-type">Zipper</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280155"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280154"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Zipper.html#Zipper"><span class="hs-identifier hs-type">Zipper</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280155"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280154"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><a href="#local-6989586621679280153"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679280155"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280167"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679280155"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280167"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-comment">-- | Maps a function over the output of the fold.</span><span>
</span><span id="line-39"></span><span class="hs-comment">--</span><span>
</span><span id="line-40"></span><span id="local-6989586621679280052"><span id="local-6989586621679280053"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679280049"><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679280053"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280053"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280052"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-41"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">fmap</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-42"></span><span>    </span><span id="local-6989586621679280047"><span class="annot"><span class="annottext">fmap :: (a -&gt; b) -&gt; Parser m a a -&gt; Parser m a b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fmap</span></span></span><span> </span><span id="local-6989586621679280046"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679280046"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679280045"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679280045"><span class="hs-identifier hs-var">parser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-43"></span><span>        </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="annot"><span class="annottext">((forall r.
  Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
 -&gt; Parser m a b)
-&gt; (forall r.
    Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679280044"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280044"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span id="local-6989586621679280043"><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280043"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679280045"><span class="hs-identifier hs-var">parser</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280044"><span class="hs-identifier hs-var">inp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280043"><span class="hs-identifier hs-var">yieldk</span></a></span><span> </span><span class="annot"><span class="annottext">((Zipper m a, Either String b) -&gt; m r)
-&gt; ((Zipper m a, Either String a) -&gt; (Zipper m a, Either String b))
-&gt; (Zipper m a, Either String a)
-&gt; m r
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Either String a -&gt; Either String b)
-&gt; (Zipper m a, Either String a) -&gt; (Zipper m a, Either String b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Either String a -&gt; Either String b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679280046"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span class="hs-comment">-- | See 'Streamly.Internal.Data.Parser.yield'.</span><span>
</span><span id="line-46"></span><span class="hs-comment">--</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- /Internal/</span><span>
</span><span id="line-48"></span><span class="hs-comment">--</span><span>
</span><span id="line-49"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#yield"><span class="hs-pragma hs-type">yield</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-50"></span><span id="local-6989586621679280118"><span id="local-6989586621679280119"><span id="local-6989586621679280120"><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#yield"><span class="hs-identifier hs-type">yield</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679280120"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280119"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280118"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280120"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-51"></span><span id="yield"><span class="annot"><span class="annottext">yield :: b -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#yield"><span class="hs-identifier hs-var hs-var">yield</span></a></span></span><span> </span><span id="local-6989586621679280041"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679280041"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Zipper m a
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679280040"><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280040"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280040"><span class="hs-identifier hs-var">yieldk</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Zipper m a
forall (m :: * -&gt; *) a. Zipper m a
</span><a href="Streamly.Internal.Data.Zipper.html#nil"><span class="hs-identifier hs-var">Z.nil</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b -&gt; Either String b
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679280041"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-52"></span><span>
</span><span id="line-53"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-54"></span><span class="hs-comment">-- Sequential applicative</span><span>
</span><span id="line-55"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-56"></span><span>
</span><span id="line-57"></span><span class="hs-comment">-- | 'Applicative' form of 'Streamly.Internal.Data.Parser.splitWith'. Note that</span><span>
</span><span id="line-58"></span><span class="hs-comment">-- this operation does not fuse, use 'Streamly.Internal.Data.Parser.splitWith'</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- when fusion is important.</span><span>
</span><span id="line-60"></span><span class="hs-comment">--</span><span>
</span><span id="line-61"></span><span id="local-6989586621679280037"><span id="local-6989586621679280038"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679280032"><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679280038"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280038"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280037"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-62"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">pure</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-63"></span><span>    </span><span id="local-6989586621679280028"><span class="annot"><span class="annottext">pure :: a -&gt; Parser m a a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Parser m a a
forall b (m :: * -&gt; *) a. b -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#yield"><span class="hs-identifier hs-var">yield</span></a></span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&lt;*&gt;</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-66"></span><span>    </span><span id="local-6989586621679280027"><span class="annot"><span class="annottext">&lt;*&gt; :: Parser m a (a -&gt; b) -&gt; Parser m a a -&gt; Parser m a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">(&lt;*&gt;)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser m a (a -&gt; b) -&gt; Parser m a a -&gt; Parser m a b
forall (m :: * -&gt; *) a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</span><span class="hs-identifier hs-var">ap</span></span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">*&gt;</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-69"></span><span>    </span><span id="local-6989586621679280026"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679280026"><span class="hs-identifier hs-var">m1</span></a></span></span><span> </span><span id="local-6989586621679280025"><span class="annot"><span class="annottext">*&gt; :: Parser m a a -&gt; Parser m a b -&gt; Parser m a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">*&gt;</span></span></span><span> </span><span id="local-6989586621679280024"><span class="annot"><span class="annottext">Parser m a b
</span><a href="#local-6989586621679280024"><span class="hs-identifier hs-var">m2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="annot"><span class="annottext">((forall r.
  Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
 -&gt; Parser m a b)
-&gt; (forall r.
    Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679280023"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280023"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span id="local-6989586621679280022"><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280022"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-70"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679280021"><span class="annot"><span class="annottext">yield1 :: (Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280021"><span class="hs-identifier hs-var hs-var">yield1</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679280020"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280020"><span class="hs-identifier hs-var">z</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679280019"><span class="annot"><span class="annottext">Either String b
</span><a href="#local-6989586621679280019"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either String b
</span><a href="#local-6989586621679280019"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-71"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="annot"><span class="annottext">b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a b
-&gt; Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a b
</span><a href="#local-6989586621679280024"><span class="hs-identifier hs-var">m2</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280020"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280022"><span class="hs-identifier hs-var">yieldk</span></a></span><span>
</span><span id="line-72"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679280018"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679280018"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a b
-&gt; Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Parser m a b
forall (m :: * -&gt; *) a b. String -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-var">die</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679280018"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280020"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280022"><span class="hs-identifier hs-var">yieldk</span></a></span><span>
</span><span id="line-73"></span><span>        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679280026"><span class="hs-identifier hs-var">m1</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280023"><span class="hs-identifier hs-var">inp</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
forall b. (Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280021"><span class="hs-identifier hs-var">yield1</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&lt;*</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-76"></span><span>    </span><span id="local-6989586621679280016"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679280016"><span class="hs-identifier hs-var">m1</span></a></span></span><span> </span><span id="local-6989586621679280015"><span class="annot"><span class="annottext">&lt;* :: Parser m a a -&gt; Parser m a b -&gt; Parser m a a
</span><a href="#local-6989586621679280015"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*</span></a></span></span><span> </span><span id="local-6989586621679280014"><span class="annot"><span class="annottext">Parser m a b
</span><a href="#local-6989586621679280014"><span class="hs-identifier hs-var">m2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r)
-&gt; Parser m a a
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="annot"><span class="annottext">((forall r.
  Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r)
 -&gt; Parser m a a)
-&gt; (forall r.
    Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r)
-&gt; Parser m a a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679280013"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280013"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span id="local-6989586621679280012"><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679280012"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-77"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679280011"><span class="annot"><span class="annottext">yield1 :: (Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679280011"><span class="hs-identifier hs-var hs-var">yield1</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679280010"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280010"><span class="hs-identifier hs-var">z</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679280009"><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679280009"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679280009"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-78"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a b
-&gt; Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a b
</span><a href="#local-6989586621679280014"><span class="hs-identifier hs-var">m2</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280010"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679280008"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280008"><span class="hs-identifier hs-var">z1</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Either String b
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679280012"><span class="hs-identifier hs-var">yieldk</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280008"><span class="hs-identifier hs-var">z1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679280009"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679280007"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679280007"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Parser m a a
forall (m :: * -&gt; *) a b. String -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-var">die</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679280007"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280010"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679280012"><span class="hs-identifier hs-var">yieldk</span></a></span><span>
</span><span id="line-80"></span><span>        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679280016"><span class="hs-identifier hs-var">m1</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280013"><span class="hs-identifier hs-var">inp</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679280011"><span class="hs-identifier hs-var">yield1</span></a></span></span></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span class="hs-comment">-- | See 'Streamly.Internal.Data.Parser.die'.</span><span>
</span><span id="line-83"></span><span class="hs-comment">--</span><span>
</span><span id="line-84"></span><span class="hs-comment">-- /Internal/</span><span>
</span><span id="line-85"></span><span class="hs-comment">--</span><span>
</span><span id="line-86"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-pragma hs-type">die</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-87"></span><span id="local-6989586621679280106"><span id="local-6989586621679280107"><span id="local-6989586621679280108"><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-type">die</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280108"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280107"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280106"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-88"></span><span id="die"><span class="annot"><span class="annottext">die :: String -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-var hs-var">die</span></a></span></span><span> </span><span id="local-6989586621679280006"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679280006"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679280005"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280005"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span id="local-6989586621679280004"><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280004"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679280004"><span class="hs-identifier hs-var">yieldk</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679280005"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; Either String b
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679280006"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="hs-comment">-- | Monad composition can be used for lookbehind parsers, we can make the</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- future parses depend on the previously parsed values.</span><span>
</span><span id="line-92"></span><span class="hs-comment">--</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- If we have to parse &quot;a9&quot; or &quot;9a&quot; but not &quot;99&quot; or &quot;aa&quot; we can use the</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- following parser:</span><span>
</span><span id="line-95"></span><span class="hs-comment">--</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-97"></span><span class="hs-comment">-- backtracking :: MonadCatch m =&gt; PR.Parser m Char String</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- backtracking =</span><span>
</span><span id="line-99"></span><span class="hs-comment">--     sequence [PR.satisfy isDigit, PR.satisfy isAlpha]</span><span>
</span><span id="line-100"></span><span class="hs-comment">--     '&lt;|&gt;'</span><span>
</span><span id="line-101"></span><span class="hs-comment">--     sequence [PR.satisfy isAlpha, PR.satisfy isDigit]</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-103"></span><span class="hs-comment">--</span><span>
</span><span id="line-104"></span><span class="hs-comment">-- We know that if the first parse resulted in a digit at the first place then</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- the second parse is going to fail.  However, we waste that information and</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- parse the first character again in the second parse only to know that it is</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- not an alphabetic char.  By using lookbehind in a 'Monad' composition we can</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- avoid redundant work:</span><span>
</span><span id="line-109"></span><span class="hs-comment">--</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-111"></span><span class="hs-comment">-- data DigitOrAlpha = Digit Char | Alpha Char</span><span>
</span><span id="line-112"></span><span class="hs-comment">--</span><span>
</span><span id="line-113"></span><span class="hs-comment">-- lookbehind :: MonadCatch m =&gt; PR.Parser m Char String</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- lookbehind = do</span><span>
</span><span id="line-115"></span><span class="hs-comment">--     x1 \&lt;-    Digit '&lt;$&gt;' PR.satisfy isDigit</span><span>
</span><span id="line-116"></span><span class="hs-comment">--          '&lt;|&gt;' Alpha '&lt;$&gt;' PR.satisfy isAlpha</span><span>
</span><span id="line-117"></span><span class="hs-comment">--</span><span>
</span><span id="line-118"></span><span class="hs-comment">--     -- Note: the parse depends on what we parsed already</span><span>
</span><span id="line-119"></span><span class="hs-comment">--     x2 &lt;- case x1 of</span><span>
</span><span id="line-120"></span><span class="hs-comment">--         Digit _ -&gt; PR.satisfy isAlpha</span><span>
</span><span id="line-121"></span><span class="hs-comment">--         Alpha _ -&gt; PR.satisfy isDigit</span><span>
</span><span id="line-122"></span><span class="hs-comment">--</span><span>
</span><span id="line-123"></span><span class="hs-comment">--     return $ case x1 of</span><span>
</span><span id="line-124"></span><span class="hs-comment">--         Digit x -&gt; [x,x2]</span><span>
</span><span id="line-125"></span><span class="hs-comment">--         Alpha x -&gt; [x,x2]</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-127"></span><span class="hs-comment">--</span><span>
</span><span id="line-128"></span><span class="hs-comment">-- See also 'Streamly.Internal.Data.Parser.concatMap'. This monad instance</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- does not fuse, use 'Streamly.Internal.Data.Parser.concatMap' when you need</span><span>
</span><span id="line-130"></span><span class="hs-comment">-- fusion.</span><span>
</span><span id="line-131"></span><span class="hs-comment">--</span><span>
</span><span id="line-132"></span><span id="local-6989586621679280002"><span id="local-6989586621679280003"><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679279998"><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679280003"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280003"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679280002"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-133"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">return</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-134"></span><span>    </span><span id="local-6989586621679279995"><span class="annot"><span class="annottext">return :: a -&gt; Parser m a a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">return</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Parser m a a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&gt;&gt;=</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-137"></span><span>    </span><span id="local-6989586621679279994"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279994"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679279993"><span class="annot"><span class="annottext">&gt;&gt;= :: Parser m a a -&gt; (a -&gt; Parser m a b) -&gt; Parser m a b
</span><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;=</span></span></span><span> </span><span id="local-6989586621679279992"><span class="annot"><span class="annottext">a -&gt; Parser m a b
</span><a href="#local-6989586621679279992"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="annot"><span class="annottext">((forall r.
  Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
 -&gt; Parser m a b)
-&gt; (forall r.
    Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679279991"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279991"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span id="local-6989586621679279990"><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679279990"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-138"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679279989"><span class="annot"><span class="annottext">yield1 :: (Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279989"><span class="hs-identifier hs-var hs-var">yield1</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679279988"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279988"><span class="hs-identifier hs-var">z</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679279987"><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679279987"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679279987"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-139"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679279986"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679279986"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a b
-&gt; Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; Parser m a b
</span><a href="#local-6989586621679279992"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679279986"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279988"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679279990"><span class="hs-identifier hs-var">yieldk</span></a></span><span>
</span><span id="line-140"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679279985"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679279985"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a b
-&gt; Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Parser m a b
forall (m :: * -&gt; *) a b. String -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-var">die</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679279985"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279988"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String b) -&gt; m r
</span><a href="#local-6989586621679279990"><span class="hs-identifier hs-var">yieldk</span></a></span><span>
</span><span id="line-141"></span><span>        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279994"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279991"><span class="hs-identifier hs-var">inp</span></a></span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279989"><span class="hs-identifier hs-var">yield1</span></a></span></span></span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="hs-comment">-- | 'Alternative' form of 'Streamly.Internal.Data.Parser.alt'. Backtrack and</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- run the second parser if the first one fails.</span><span>
</span><span id="line-145"></span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- The &quot;some&quot; and &quot;many&quot; operations of alternative accumulate results in a pure</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- list which is not scalable and streaming. Instead use</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- 'Streamly.Internal.Data.Parser.some' and</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- 'Streamly.Internal.Data.Parser.many' for fusible operations with composable</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- accumulation of results.</span><span>
</span><span id="line-151"></span><span class="hs-comment">--</span><span>
</span><span id="line-152"></span><span class="hs-comment">-- See also 'Streamly.Internal.Data.Parser.alt'. This 'Alternative' instance</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- does not fuse, use 'Streamly.Internal.Data.Parser.alt' when you need</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- fusion.</span><span>
</span><span id="line-155"></span><span class="hs-comment">--</span><span>
</span><span id="line-156"></span><span id="local-6989586621679279983"><span id="local-6989586621679279984"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679279984"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679279984"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679279983"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">empty</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-158"></span><span>    </span><span id="local-6989586621679279975"><span class="annot"><span class="annottext">empty :: Parser m a a
</span><a href="#local-6989586621679279975"><span class="hs-identifier hs-var hs-var hs-var hs-var">empty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Parser m a a
forall (m :: * -&gt; *) a b. String -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-var">die</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;empty&quot;</span></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="hs-pragma">(</span><span class="hs-pragma">&lt;|&gt;</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-161"></span><span>    </span><span id="local-6989586621679279973"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279973"><span class="hs-identifier hs-var">m1</span></a></span></span><span> </span><span id="local-6989586621679279972"><span class="annot"><span class="annottext">&lt;|&gt; :: Parser m a a -&gt; Parser m a a -&gt; Parser m a a
</span><a href="#local-6989586621679279972"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;|&gt;</span></a></span></span><span> </span><span id="local-6989586621679279971"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279971"><span class="hs-identifier hs-var">m2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r)
-&gt; Parser m a a
forall (m :: * -&gt; *) a b.
(forall r.
 Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r)
-&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#MkParser"><span class="hs-identifier hs-var">MkParser</span></a></span><span> </span><span class="annot"><span class="annottext">((forall r.
  Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r)
 -&gt; Parser m a a)
-&gt; (forall r.
    Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r)
-&gt; Parser m a a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679279970"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279970"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span id="local-6989586621679279969"><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279969"><span class="hs-identifier hs-var">yieldk</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-162"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679279968"><span class="annot"><span class="annottext">yield1 :: (Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279968"><span class="hs-identifier hs-var hs-var">yield1</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679279967"><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279967"><span class="hs-identifier hs-var">z</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679279966"><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679279966"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679279966"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-163"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279969"><span class="hs-identifier hs-var">yieldk</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Zipper m a -&gt; Zipper m a
forall (m :: * -&gt; *) a. Zipper m a -&gt; Zipper m a
</span><a href="Streamly.Internal.Data.Zipper.html#release"><span class="hs-identifier hs-var">Z.release</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279967"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Either String a
</span><a href="#local-6989586621679279966"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279971"><span class="hs-identifier hs-var">m2</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Zipper m a -&gt; Zipper m a
forall (m :: * -&gt; *) a. Zipper m a -&gt; Zipper m a
</span><a href="Streamly.Internal.Data.Zipper.html#restore"><span class="hs-identifier hs-var">Z.restore</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279967"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279969"><span class="hs-identifier hs-var">yieldk</span></a></span><span>
</span><span id="line-165"></span><span>        </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parser m a a
-&gt; Zipper m a -&gt; ((Zipper m a, Either String a) -&gt; m r) -&gt; m r
forall (m :: * -&gt; *) a b.
Parser m a b
-&gt; forall r.
   Zipper m a -&gt; ((Zipper m a, Either String b) -&gt; m r) -&gt; m r
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#runParser"><span class="hs-identifier hs-var hs-var">runParser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279973"><span class="hs-identifier hs-var">m1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Zipper m a -&gt; Zipper m a
forall (m :: * -&gt; *) a. Zipper m a -&gt; Zipper m a
</span><a href="Streamly.Internal.Data.Zipper.html#checkpoint"><span class="hs-identifier hs-var">Z.checkpoint</span></a></span><span> </span><span class="annot"><span class="annottext">Zipper m a
</span><a href="#local-6989586621679279970"><span class="hs-identifier hs-var">inp</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Zipper m a, Either String a) -&gt; m r
</span><a href="#local-6989586621679279968"><span class="hs-identifier hs-var">yield1</span></a></span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span>    </span><span class="hs-comment">-- some and many are implemented here instead of using default definitions</span><span>
</span><span id="line-168"></span><span>    </span><span class="hs-comment">-- so that we can use INLINE on them. It gives 50% performance improvement.</span><span>
</span><span id="line-169"></span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">many</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-171"></span><span>    </span><span id="local-6989586621679279961"><span class="annot"><span class="annottext">many :: Parser m a a -&gt; Parser m a [a]
</span><a href="#local-6989586621679279961"><span class="hs-identifier hs-var hs-var hs-var hs-var">many</span></a></span></span><span> </span><span id="local-6989586621679279960"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279960"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser m a [a]
</span><a href="#local-6989586621679279959"><span class="hs-identifier hs-var">many_v</span></a></span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span>        </span><span id="local-6989586621679279959"><span class="annot"><span class="annottext">many_v :: Parser m a [a]
</span><a href="#local-6989586621679279959"><span class="hs-identifier hs-var hs-var">many_v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser m a [a]
</span><a href="#local-6989586621679279958"><span class="hs-identifier hs-var">some_v</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a [a] -&gt; Parser m a [a] -&gt; Parser m a [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parser m a [a]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-176"></span><span>        </span><span id="local-6989586621679279958"><span class="annot"><span class="annottext">some_v :: Parser m a [a]
</span><a href="#local-6989586621679279958"><span class="hs-identifier hs-var hs-var">some_v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; Parser m a a -&gt; Parser m a ([a] -&gt; [a])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279960"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a ([a] -&gt; [a]) -&gt; Parser m a [a] -&gt; Parser m a [a]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser m a [a]
</span><a href="#local-6989586621679279959"><span class="hs-identifier hs-var">many_v</span></a></span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">some</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-179"></span><span>    </span><span id="local-6989586621679279955"><span class="annot"><span class="annottext">some :: Parser m a a -&gt; Parser m a [a]
</span><a href="#local-6989586621679279955"><span class="hs-identifier hs-var hs-var hs-var hs-var">some</span></a></span></span><span> </span><span id="local-6989586621679279954"><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279954"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser m a [a]
</span><a href="#local-6989586621679279953"><span class="hs-identifier hs-var">some_v</span></a></span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span>        </span><span id="local-6989586621679279952"><span class="annot"><span class="annottext">many_v :: Parser m a [a]
</span><a href="#local-6989586621679279952"><span class="hs-identifier hs-var hs-var">many_v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser m a [a]
</span><a href="#local-6989586621679279953"><span class="hs-identifier hs-var">some_v</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a [a] -&gt; Parser m a [a] -&gt; Parser m a [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parser m a [a]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-184"></span><span>        </span><span id="local-6989586621679279953"><span class="annot"><span class="annottext">some_v :: Parser m a [a]
</span><a href="#local-6989586621679279953"><span class="hs-identifier hs-var hs-var">some_v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; Parser m a a -&gt; Parser m a ([a] -&gt; [a])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser m a a
</span><a href="#local-6989586621679279954"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Parser m a ([a] -&gt; [a]) -&gt; Parser m a [a] -&gt; Parser m a [a]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser m a [a]
</span><a href="#local-6989586621679279952"><span class="hs-identifier hs-var">many_v</span></a></span></span></span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span class="hs-comment">-- | 'mzero' is same as 'empty', it aborts the parser. 'mplus' is same as</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- '&lt;|&gt;', it selects the first succeeding parser.</span><span>
</span><span id="line-188"></span><span class="hs-comment">--</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- /Internal/</span><span>
</span><span id="line-190"></span><span class="hs-comment">--</span><span>
</span><span id="line-191"></span><span id="local-6989586621679279950"><span id="local-6989586621679279951"><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679279951"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadPlus</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679279951"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679279950"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">mzero</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-193"></span><span>    </span><span id="local-6989586621679279943"><span class="annot"><span class="annottext">mzero :: Parser m a a
</span><a href="#local-6989586621679279943"><span class="hs-identifier hs-var hs-var hs-var hs-var">mzero</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Parser m a a
forall (m :: * -&gt; *) a b. String -&gt; Parser m a b
</span><a href="Streamly.Internal.Data.Parser.ParserK.Types.html#die"><span class="hs-identifier hs-var">die</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mzero&quot;</span></span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><span class="hs-pragma hs-type">mplus</span></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-196"></span><span>    </span><span id="local-6989586621679279941"><span class="annot"><span class="annottext">mplus :: Parser m a a -&gt; Parser m a a -&gt; Parser m a a
</span><a href="#local-6989586621679279941"><span class="hs-identifier hs-var hs-var hs-var hs-var">mplus</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser m a a -&gt; Parser m a a -&gt; Parser m a a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">(&lt;|&gt;)</span></span></span></span><span>
</span><span id="line-197"></span></pre></body></html>